import { Segment } from "./transcribe-ai.service";

export interface SubtitleSettings {
  wordedCaptions: boolean;
  speakerInCaptions: boolean;
  multiColorCaptions: boolean;
  speakerIdMap: {
    [key: string]: {
      name?: string;
      captionColor?: string;
    };
  };
}
export class SubtitleService {
  processVttFile(segments: Segment[], settings?: SubtitleSettings) {
    let body = `WEBVTT\n`;

    let cuesCount = 1;
    body += this.addVTTStyleBlock(settings);
    for (const segment of segments) {
      const speakerId = segment.speaker_id;

      for (const transcription of segment.transcriptions) {
        const startStr = this.secondsToString(transcription.start);
        const endStr = this.secondsToString(transcription.end);

        let prefix = "";

        if (settings?.speakerInCaptions) {
          const name = settings.speakerIdMap[speakerId]?.name || speakerId;
          prefix = `[${name}] `;
        }

        body += "\n\n";
        body += `${cuesCount}\n`;
        body += `${startStr} --> ${endStr} align:center\n`;
        body += `<v ${speakerId}>${prefix + transcription.word.trim()}</v>`;
        cuesCount++;
      }
    }
    console.log(body);
    return new Blob([body], { type: "text/plain" });
  }

  private addVTTStyleBlock(settings?: SubtitleSettings) {
    if (!settings || !settings.multiColorCaptions) {
      return "";
    }
    let styleBlock = "";
    for (const id of Object.keys(settings.speakerIdMap)) {
      styleBlock += "STYLE\n";
      styleBlock += `::cue(v[voice="${id}"]) { color: ${
        settings.speakerIdMap[id].captionColor || "#FFFFFF"
      }; font-weight: bold; }\n\n`;
    }
    return styleBlock;
  }

  private secondsToString(value: number) {
    const hours = value / 3600;

    const minutes = (hours - Math.trunc(hours)) * 60;

    const seconds = (minutes - Math.trunc(minutes)) * 60;

    const miliseconds = seconds - Math.trunc(seconds);

    return `${String(Math.trunc(hours)).padStart(2, "0")}:${String(
      Math.trunc(minutes)
    ).padStart(2, "0")}:${String(Math.trunc(seconds)).padStart(
      2,
      "0"
    )}.${String(miliseconds.toFixed(3)).replace("0.", "")}`;
  }

  processAssFile(segments: Segment[], settings?: SubtitleSettings) {
    const header = this.getAssHeader();
    let body = "";

    for (const segment of segments) {
      const speakerId = segment.speaker_id;

      for (const transcription of segment.transcriptions) {
        const startStr = this.secondsToAssTime(transcription.start);
        const endStr = this.secondsToAssTime(transcription.end);

        let text = transcription.word.trim();

        if (settings?.speakerInCaptions) {
          const name = settings.speakerIdMap[speakerId]?.name || speakerId;
          text = `[${name}] ${text}`;
        }

        body += `Dialogue: 0,${startStr},${endStr},Default,,0,0,0,,${text}\n`;
      }
    }

    const assContent = header + body;
    console.log(assContent)
    return new Blob([assContent], { type: "text/plain" });
  }

  private getAssHeader() {
    return `
[Script Info]
; Script generated by SubtitleService
Title: ASS Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H00FFFFFF,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
  }

  private secondsToAssTime(value: number) {
    const hours = Math.floor(value / 3600);
    const minutes = Math.floor((value % 3600) / 60);
    const seconds = value % 60;
    const milliseconds = Math.floor((seconds % 1) * 100);

    return `${String(hours).padStart(1, "0")}:${String(minutes).padStart(
      2,
      "0"
    )}:${String(Math.floor(seconds)).padStart(2, "0")}.${String(
      milliseconds
    ).padStart(2, "2")}`;
  }
}
